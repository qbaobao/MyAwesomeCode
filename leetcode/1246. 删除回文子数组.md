# 1236. 删除回文子数组

#### [1246. 删除回文子数组](https://leetcode-cn.com/problems/palindrome-removal/)

## 题目

给你一个整数数组 arr，每一次操作你都可以选择并删除它的一个 回文 子数组 arr[i], arr[i+1], ..., arr[j]（ i <= j）。

注意，每当你删除掉一个子数组，右侧元素都会自行向前移动填补空位。

**请你计算并返回从数组中删除所有数字所需的最少操作次数**。

 ```
示例 1：
输入：arr = [1,2]
输出：2
 ```

```
示例 2：
输入：arr = [1,3,4,1,5]
输出：3
解释：先删除 [4]，然后删除 [1,3,1]，最后再删除 [5]。
```

> 提示：
>
> 1 <= arr.length <= 100
>
> 1 <= arr[i] <= 20



## 分析

**看到回文首先应该想到动态规划**，首先让我们回忆一下，*求字符串中最长回文字符串长度的问题*如何做？

dp[i] [j]，表示以str[i..j]是否是回文字符。

dp[i] [j] = dp[i + 1] [j - 1] == true ? str[i] == str[j] : false; 同时字符串中回文的长度和起始位置

```
看到回文相关的题目一定要用二位动态规划!!!
```

再回到这道题，这道题要求的是，最少通过多少次移动可以将数组元素全部移除。题目中的技巧在于，可以通过构造回文字符串，更快的移除更多的字符。回文字符串的关键点是什么呢？**中心对称**。

我们假设dp[i] [j]表示移除arr[i..j]需要的次数。

所以对于arr[i..j]，

+ arr[i] == arr[j]，那么[i..j]可以先构造成回文字符串，然后arr[i]和arr[j]可以通过一次操作移除。那么此种场景下，

  ```c
  dp[i][j] = dp[i + 1][j - 1]
  ```

  怎么理解呢？我们假设arr[i + 1..j - 1]是回文字符串，那么arr[i..j]也就是回文字符串，可以同时移除[i..j]的所有元素；假设arr[i + 1..j - 1]不是回文字符串，那么需要一个一个的移除[i + 1..j - 1]的元素，直到[i + 1..j - 1]中只剩下一个元素，此时，剩下的这一个元素k可以与[i,j]构成了回文，[i, k, j]三个元素可以一起移除。

+ arr[i] != arr[j]，那么我们就需要暴力的遍历k(i <= k <= j)，计算移除[i..k] [k+1..j]的总步骤数，找到使[i..j]移除最少步骤的k。 所以此时：

  ```c
  dp[i][j] = min(dp[i][k] + dp[k+1][j]) (i <= k <= j)
  ```

我们的终极目标是求出**dp[0] [size - 1]**

对于新手来说，不容易想到的应该是arr[i] != arr[j]的时候，如何更新dp[i] [j]。希望能够记住这个典型的例题。

## 代码

```c
int minimumMoves(int* arr, int arrSize){
    if (arrSize == 1) {
        return 1;
    }
    int dp[101][101];
    memset(dp, 101, sizeof(dp));
    for (int i = 0; i < arrSize; i++) {
        dp[i][i] = 1;
        if (i < arrSize - 1) {
            dp[i][i + 1] = (arr[i] == arr[i + 1]) ? 1 : 2;
        }
    }
    for (int len = 3; len <= arrSize; len++) {
        for (int i = 0; i <= arrSize - len; i++) {
            if (arr[i] == arr[i + len - 1] && dp[i][i + len - 1] > dp[i + 1][i + len - 2]) {
                dp[i][i + len - 1] = dp[i + 1][i + len - 2];
            }
            for (int k = i; k <= i + len - 1; k++) {
                if (dp[i][i + len - 1] > dp[i][k] + dp[k + 1][i + len - 1]) {
                    dp[i][i + len - 1] = dp[i][k] + dp[k + 1][i + len - 1];
                }
            }
        }
    }
    return dp[0][arrSize - 1];
}
```

